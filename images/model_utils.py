# Utility methods used by models.py.
#
# These methods should not import anything from models.py.  Otherwise,
# there will be circular import dependencies.  Utility functions
# that use models.py should go in the general utility functions
# file, utils.py.
from decimal import Decimal
import math

class PointGen():
    """
    - Defines types of point generation.
    - Has methods for going between human-readable format and DB-friendly encoding
    of the point generation method.

    Examples of the DB-friendly encoding:
    m_80 -> Simple random, 80 points
    t_8_6_4 -> Stratified random, 8x6 cells, 4 points per cell
    u_10_8 -> Uniform grid, 10x8 grid
    i_80 -> Imported, 80 points
    """
    class Types():
        SIMPLE = 'm'
        SIMPLE_VERBOSE = 'Simple Random (Random within the entire annotation area)'
        STRATIFIED = 't'
        STRATIFIED_VERBOSE = 'Stratified Random (Random within a cell of the annotation area)'
        UNIFORM = 'u'
        UNIFORM_VERBOSE = 'Uniform Grid'
        IMPORTED = 'i'
        IMPORTED_VERBOSE = 'Imported (Not generated by CoralNet)'

    @staticmethod
    def args_to_db_format(point_generation_type=None,
                          simple_number_of_points=None,
                          number_of_cell_rows=None,
                          number_of_cell_columns=None,
                          stratified_points_per_cell=None,
                          imported_number_of_points=None):

        if point_generation_type == PointGen.Types.SIMPLE:
            extraArgs = [simple_number_of_points]
        elif point_generation_type == PointGen.Types.STRATIFIED:
            extraArgs = [number_of_cell_rows,
                          number_of_cell_columns,
                          stratified_points_per_cell]
        elif point_generation_type == PointGen.Types.UNIFORM:
            extraArgs = [number_of_cell_rows,
                          number_of_cell_columns]
        elif point_generation_type == PointGen.Types.IMPORTED:
            extraArgs = [imported_number_of_points]
        else:
            raise ValueError("Point generation type is not a known type.")

        for arg in extraArgs:
            if arg is None:
                raise ValueError("Point generation method is missing a required argument.")

        # Make sure we have strings, not ints
        extraArgs = [str(arg) for arg in extraArgs]

        return '_'.join([point_generation_type] + extraArgs)

    @staticmethod
    def args_to_readable_format(point_generation_type=None,
                                simple_number_of_points=None,
                                number_of_cell_rows=None,
                                number_of_cell_columns=None,
                                stratified_points_per_cell=None,
                                imported_number_of_points=None):

        if point_generation_type == PointGen.Types.SIMPLE:
            return "Simple random, %s points" % simple_number_of_points
        elif point_generation_type == PointGen.Types.STRATIFIED:
            return "Stratified random, %s rows x %s columns of cells, %s points per cell (total of %s points)" % (
                   number_of_cell_rows, number_of_cell_columns, stratified_points_per_cell,
                   number_of_cell_rows*number_of_cell_columns*stratified_points_per_cell
                )
        elif point_generation_type == PointGen.Types.UNIFORM:
            return "Uniform grid, %s rows x %s columns (total of %s points)" % (
                   number_of_cell_rows, number_of_cell_columns,
                   number_of_cell_rows*number_of_cell_columns
                )
        elif point_generation_type == PointGen.Types.IMPORTED:
            return "Imported, %s points" % imported_number_of_points
        else:
            raise ValueError("Point generation type is not a known type.")

    @staticmethod
    def db_to_args_format(db_format):
        tokens = db_format.split('_')

        if tokens[0] == PointGen.Types.SIMPLE:
            return dict(point_generation_type=tokens[0],
                        simple_number_of_points=int(tokens[1]))

        elif tokens[0] == PointGen.Types.STRATIFIED:
            return dict(point_generation_type=tokens[0],
                        number_of_cell_rows=int(tokens[1]),
                        number_of_cell_columns=int(tokens[2]),
                        stratified_points_per_cell=int(tokens[3]))

        elif tokens[0] == PointGen.Types.UNIFORM:
            return dict(point_generation_type=tokens[0],
                        number_of_cell_rows=int(tokens[1]),
                        number_of_cell_columns=int(tokens[2]))

        elif tokens[0] == PointGen.Types.IMPORTED:
            return dict(point_generation_type=tokens[0],
                        imported_number_of_points=int(tokens[1]))

    @staticmethod
    def db_to_readable_format(db_format):
        return PointGen.args_to_readable_format(**PointGen.db_to_args_format(db_format))


class AnnotationAreaUtils():

    # Percentages are decimals.
    # Pixels are integers.
    # Database (db) format:
    #     percentages - "5.7;94.5;10;90"
    #     pixels - "125,1880,80,1600"

    IMPORTED_STR = 'imported'
    IMPORTED_DISPLAY = "(Imported points; not specified)"
    TYPE_PERCENTAGES = 'percentages'
    TYPE_PIXELS = 'pixels'
    TYPE_IMPORTED = 'imported'

    @staticmethod
    def percentages_to_db_format(min_x, max_x, min_y, max_y):
        return ';'.join([
            str(min_x), str(max_x), str(min_y), str(max_y)
        ])

    @staticmethod
    def pixels_to_db_format(min_x, max_x, min_y, max_y):
        return ','.join([
            str(min_x), str(max_x), str(min_y), str(max_y)
        ])

    @staticmethod
    def db_format_to_numbers(s):
        d = dict()
        if s == AnnotationAreaUtils.IMPORTED_STR:
            d['type'] = AnnotationAreaUtils.TYPE_IMPORTED
        elif s.find(';') != -1:
            # percentages
            d['min_x'], d['max_x'], d['min_y'], d['max_y'] = [Decimal(dec_str) for dec_str in s.split(';')]
            d['type'] = AnnotationAreaUtils.TYPE_PERCENTAGES
        elif s.find(',') != -1:
            # pixels
            d['min_x'], d['max_x'], d['min_y'], d['max_y'] = [int(int_str) for int_str in s.split(',')]
            d['type'] = AnnotationAreaUtils.TYPE_PIXELS
        else:
            raise ValueError("Annotation area isn't in a valid DB format.")
        return d

    @staticmethod
    def db_format_to_percentages(s):
        d = AnnotationAreaUtils.db_format_to_numbers(s)
        if d['type'] == AnnotationAreaUtils.TYPE_PERCENTAGES:
            return d
        else:
            raise ValueError("Annotation area type is '{0}' expected {1}.".format(
                d['type'], AnnotationAreaUtils.TYPE_PERCENTAGES))

    @staticmethod
    def db_format_to_display(s):
        d = AnnotationAreaUtils.db_format_to_numbers(s)

        if d['type'] == AnnotationAreaUtils.TYPE_IMPORTED:
            return AnnotationAreaUtils.IMPORTED_DISPLAY
        elif d['type'] == AnnotationAreaUtils.TYPE_PERCENTAGES:
            return "X: {0} - {1}% / Y: {2} - {3}%".format(
                d['min_x'], d['max_x'], d['min_y'], d['max_y']
            )
        elif d['type'] == AnnotationAreaUtils.TYPE_PIXELS:
            return "X: {0} - {1} pixels / Y: {2} - {3} pixels".format(
                d['min_x'], d['max_x'], d['min_y'], d['max_y']
            )

    @staticmethod
    def percentages_to_pixels(min_x, max_x, min_y, max_y, width, height):
        d = dict()

        # The percentages are Decimals.
        # Decimal / int = Decimal, and Decimal * int = Decimal
        d['min_x'] = (min_x / 100) * width
        d['max_x'] = (max_x / 100) * width
        d['min_y'] = (min_y / 100) * height
        d['max_y'] = (max_y / 100) * height

        for key in d.keys():
            # Convert to integer pixel values.
            # Round up (could just as well round down, need to pick one or the other).
            d[key] = int(math.ceil(d[key]))

            # Corner case
            if d[key] == 0:
                d[key] = 1

        return d
