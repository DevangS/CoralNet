# Utility methods used by models.py.
#
# These methods should not import anything from models.py.  Otherwise,
# there will be circular import dependencies.  Utility functions
# that use models.py should go in the general utility functions
# file, utils.py.
from decimal import Decimal
import math

class PointGen():
    """
    - Defines types of point generation.
    - Has methods for going between human-readable format and DB-friendly encoding
    of the point generation method.

    Examples of the DB-friendly encoding:
    m_80 -> Simple random, 80 points
    t_8_6_4 -> Stratified random, 8x6 cells, 4 points per cell
    u_10_8 -> Uniform grid, 10x8 grid
    i_80 -> Imported, 80 points
    """
    class Types():
        SIMPLE = 'm'
        SIMPLE_VERBOSE = 'Simple Random (Random within the entire annotation area)'
        STRATIFIED = 't'
        STRATIFIED_VERBOSE = 'Stratified Random (Random within a cell of the annotation area)'
        UNIFORM = 'u'
        UNIFORM_VERBOSE = 'Uniform Grid'
        IMPORTED = 'i'
        IMPORTED_VERBOSE = 'Imported (Not generated by CoralNet)'

    @staticmethod
    def args_to_db_format(point_generation_type=None,
                          simple_number_of_points=None,
                          number_of_cell_rows=None,
                          number_of_cell_columns=None,
                          stratified_points_per_cell=None,
                          imported_number_of_points=None):

        if point_generation_type == PointGen.Types.SIMPLE:
            extraArgs = [simple_number_of_points]
        elif point_generation_type == PointGen.Types.STRATIFIED:
            extraArgs = [number_of_cell_rows,
                          number_of_cell_columns,
                          stratified_points_per_cell]
        elif point_generation_type == PointGen.Types.UNIFORM:
            extraArgs = [number_of_cell_rows,
                          number_of_cell_columns]
        elif point_generation_type == PointGen.Types.IMPORTED:
            extraArgs = [imported_number_of_points]
        else:
            raise ValueError("Point generation type is not a known type.")

        for arg in extraArgs:
            if arg is None:
                raise ValueError("Point generation method is missing a required argument.")

        # Make sure we have strings, not ints
        extraArgs = [str(arg) for arg in extraArgs]

        return '_'.join([point_generation_type] + extraArgs)

    @staticmethod
    def args_to_readable_format(point_generation_type=None,
                                simple_number_of_points=None,
                                number_of_cell_rows=None,
                                number_of_cell_columns=None,
                                stratified_points_per_cell=None,
                                imported_number_of_points=None):

        if point_generation_type == PointGen.Types.SIMPLE:
            return "Simple random, %s points" % simple_number_of_points
        elif point_generation_type == PointGen.Types.STRATIFIED:
            return "Stratified random, %s rows x %s columns of cells, %s points per cell (total of %s points)" % (
                   number_of_cell_rows, number_of_cell_columns, stratified_points_per_cell,
                   number_of_cell_rows*number_of_cell_columns*stratified_points_per_cell
                )
        elif point_generation_type == PointGen.Types.UNIFORM:
            return "Uniform grid, %s rows x %s columns (total of %s points)" % (
                   number_of_cell_rows, number_of_cell_columns,
                   number_of_cell_rows*number_of_cell_columns
                )
        elif point_generation_type == PointGen.Types.IMPORTED:
            return "Imported, %s points" % imported_number_of_points
        else:
            raise ValueError("Point generation type is not a known type.")

    @staticmethod
    def db_to_args_format(db_format):
        tokens = db_format.split('_')

        if tokens[0] == PointGen.Types.SIMPLE:
            return dict(point_generation_type=tokens[0],
                        simple_number_of_points=int(tokens[1]))

        elif tokens[0] == PointGen.Types.STRATIFIED:
            return dict(point_generation_type=tokens[0],
                        number_of_cell_rows=int(tokens[1]),
                        number_of_cell_columns=int(tokens[2]),
                        stratified_points_per_cell=int(tokens[3]))

        elif tokens[0] == PointGen.Types.UNIFORM:
            return dict(point_generation_type=tokens[0],
                        number_of_cell_rows=int(tokens[1]),
                        number_of_cell_columns=int(tokens[2]))

        elif tokens[0] == PointGen.Types.IMPORTED:
            return dict(point_generation_type=tokens[0],
                        imported_number_of_points=int(tokens[1]))

    @staticmethod
    def db_to_readable_format(db_format):
        return PointGen.args_to_readable_format(**PointGen.db_to_args_format(db_format))


class AnnotationAreaUtils():

    @staticmethod
    def percentage_decimals_to_string(min_x, max_x, min_y, max_y):
        # Handle the case where the field is not filled at all.
        if min_x is None and max_x is None and \
           min_y is None and max_y is None:
            return ''

        return ','.join([
            str(min_x), str(max_x), str(min_y), str(max_y)
        ])

    @staticmethod
    def percentage_string_to_decimals(s):
        d = dict()
        d['min_x'], d['max_x'], d['min_y'], d['max_y'] = [Decimal(dec_str) for dec_str in s.split(',')]
        return d

    @staticmethod
    def pixel_integers_to_string(min_x, max_x, min_y, max_y):
        # Handle the case where the field is not filled at all.
        if min_x is None and max_x is None and \
           min_y is None and max_y is None:
            return ''

        return ','.join([
            str(min_x), str(max_x), str(min_y), str(max_y)
        ])

    @staticmethod
    def pixel_string_to_integers(s):
        d = dict()
        d['min_x'], d['max_x'], d['min_y'], d['max_y'] = [int(int_str) for int_str in s.split(',')]
        return d

    @staticmethod
    def percentages_to_pixels(min_x, max_x, min_y, max_y, width, height):
        d = dict()

        # The percentages are Decimals.
        # Decimal / int = Decimal, and Decimal * int = Decimal
        d['min_x'] = (min_x / 100) * width
        d['max_x'] = (max_x / 100) * width
        d['min_y'] = (min_y / 100) * height
        d['max_y'] = (max_y / 100) * height

        for key in d.keys():
            # Convert to integer pixel values.
            # Round up (could just as well round down, need to pick one or the other).
            d[key] = int(math.ceil(d[key]))

            # Corner case
            if d[key] == 0:
                d[key] = 1

        return d

    @staticmethod
    def percentage_string_to_readable_format(s):
        d = AnnotationAreaUtils.percentage_string_to_decimals(s)
        return "X: %s - %s%% / Y: %s - %s%%" % (
            d['min_x'], d['max_x'], d['min_y'], d['max_y']
            )

    @staticmethod
    def pixel_string_to_readable_format(s):
        d = AnnotationAreaUtils.pixel_string_to_integers(s)
        return "X: %s - %s pixels / Y: %s - %s pixels" % (
            d['min_x'], d['max_x'], d['min_y'], d['max_y']
            )

    @staticmethod
    def percentage_string_to_pixels_readable_format(s, width, height):
        percent_d = AnnotationAreaUtils.percentage_string_to_decimals(s)
        pixel_d = AnnotationAreaUtils.percentages_to_pixels(width=width, height=height, **percent_d)
        return "X: %s - %s pixels (%s - %s%%) / Y: %s - %s pixels (%s - %s%%)" % (
            pixel_d['min_x'], pixel_d['max_x'],
            percent_d['min_x'], percent_d['max_x'],
            pixel_d['min_y'], pixel_d['max_y'],
            percent_d['min_y'], percent_d['max_y']
            )