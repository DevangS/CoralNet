function np = gridCrawler(vp, fval, gridParams)
% np = gridCrawler(vp, fval, gridParams)
%
% GRIDCRAWLER uses an iterative gridsearch method to find local min. Works for N dimensions and
% for M levels of zoom. Once the method has reached a local minima for a
% zoom level it proceeds with the next, or returns an empty output which
% indicates convergence. The points returned by the method needs to be
% evaluated by the objective function and returned with corresponding
% function values.
%
% INPUTS
% vp, visitedPoints, is a [W x N] matrix where W indicates number of visited points so far.
% First function call will have vp = [ ].
% fval is a 1 x N vector with function values corresponding to each visited
% point. First function call will have fval = [].
%
% gridParams is a parameter struct with the following fields.
% gridParams.range.min = 1 x N
% gridParams.range.max = 1 x N
% gridParams.stepsize = M x N
% gridParams.start = 1 x N
% gridParams.edgeLength = indicates the size of each grid. Must be an odd
% number. Usually 3 or 5 for fast convergence.
%
% gridParams.maxNbrMinPoints = when we find this number of minpoints the
% current zoom level is considered as done. This is to avoid dragging along
% the bottom of a "wedge". Usually set to 2.
%
% gridParams.plausibleInfPointsRemoval = true or false; This function will,
% if it notices that for a given xvalue (in any dimension) there
% are more than 1 'inf' fval associated, not generate more gridpoints with
% that xvalue. 
%
% OUTPUTS
% np, NewPoints are the points generated by gridCrawler where the objective
% function needs to be evaluated. If this output is empty the search has
% converged.
%
% Version 2.0
% NOTE: the 'log' option has been removed in this version for a simpler interface. If you wish to
% perform a logarithmic gridsearch, just take the exponential of the
% generated points.
%
% Oscar Beijbom [20 Feb 2010]




[ok, message] = okInputs(gridParams);
if (~ok)
    error(message);
end

% If all fval == inf. Abort.
if ( ~isempty(vp) && sum(fval == Inf) == length(fval) )
    return
end

%local variables.
ndims = length(gridParams.start);
nbrZooms = size(gridParams.stepsize,1);

% initializing
if (isempty(vp))
    stepsizeIndex = 1;
    newGridCenter = gridParams.start;
else
    minDist = findMinDist(vp);
    diff = abs(gridParams.stepsize - repmat(minDist, nbrZooms, 1)) < (eps * 100);
    stepsizeIndex = find(sum(diff,2) == ndims, 1, 'last');
    newGridCenter = vp(fval == min(fval),:); %might be more than one, but thats ok!
end

done = false;


% check if we have exceeded the maximum amount of gridcenters.
if size( newGridCenter, 1 ) > gridParams.maxNbrMinPoints
    if (stepsizeIndex == nbrZooms) %klara!
        done = true;
    else
        stepsizeIndex = stepsizeIndex + 1; %zooms!
        % new gridcenter will be the gridCenter closes to the center of
        % gravity of all old ones.
        newGridCenter = findNewGridCenter(newGridCenter);
    end
end


while (~done)
    % create new points.
    np = createNewPoints(newGridCenter, gridParams.edgeLength, gridParams.stepsize(stepsizeIndex, :), size(gridParams.start,2));
    
    % remove duplicates
    np = removeDoubles(np);
    
    % remove those that already exist in vp.
    np = removeExisting(np, vp);
    
    % remove those outside the boundaries
    np = removeOutsideBoundaries(np, gridParams.range);
    
    % if PlausibleInfPointRemoval do that.
    if gridParams.plausibleInfPointsRemoval
        np = removePlausibleInfPoints(np, vp, fval);
    end
    
    if (isempty(np))
        if (stepsizeIndex == nbrZooms) %done!
            done = true;
        else
            stepsizeIndex = stepsizeIndex + 1; %zoomar!
            
            %s�tter den nya gridcentern = punkt som ligger n�rmast
            %tyngdpunkten av alla minpunkter.
            newGridCenter = findNewGridCenter(newGridCenter);
        end
    else
        done = true;
    end
    
end

end

function minDist = findMinDist(vp)
ndims = size(vp, 2);
minDist = inf(1, ndims);
for d = 1 : ndims
    checkpoints = unique(vp(:,d));   
    for i = 1 : length(checkpoints) - 1
        for j = i + 1 : length(checkpoints)
            thisDist = abs(checkpoints(i) - checkpoints(j));
            if thisDist < minDist(d);
                minDist(d) = thisDist;
            end
        end
    end
end
end

function np = createNewPoints(newGridCenter, edgeLength, stepsize, ndims)

lasso = generatelasso(ndims, ceil((edgeLength - 2)/2), edgeLength - 2);
np = zeros(size(lasso,1)*size(newGridCenter, 1), ndims);
pos = 1;
for k = 1 : size(newGridCenter, 1)
    thisGridCenter = newGridCenter(k, :);
    for l = 1 : size(lasso, 1)
        np(pos, :) = thisGridCenter + lasso(l,:) .* stepsize;
        pos = pos + 1;
    end
end
end

function np = removeDoubles(np)
keepNP = true(size(np, 1), 1);
for i = 1 : size(np) - 1
    for j = i + 1 : size(np)
        if ( norm(np(i,:) - np(j,:)) < ( eps * 100 ) )
            keepNP(i) = false;
        end
    end
end
np = np(keepNP,:);
end

function np = removeExisting(np, vp)
% ta bort de som redan finns!
keepNP = true(size(np, 1), 1);
for i = 1 : size(np)
    for j = 1 : size(vp)
        if ( norm(np(i,:) - vp(j,:)) < ( eps * 100 ) )
            keepNP(i) = false;
        end
    end
end
np = np(keepNP,:);
end

function np = removePlausibleInfPoints(np, vp, fval)

if (isempty(np)) || isempty(vp)
    return
end

ndims = size(np, 2);
keepNP = true(size(np, 1), 1);
for d = 1 : ndims
    values = unique(vp(:, d));    
    for i = 1 : length(values)
        nbrInf = sum(fval(vp(:, d) == values(i)) == Inf);
        if nbrInf > 1
            keepNP( abs(np(:, d) - values(i)) < (eps * 100) ) = false;
        end
    end   
end
np = np(keepNP,:);
end


function newGridCenter = findNewGridCenter(gridCenters)

COG = mean(gridCenters, 1); %center of gravity

%hitta den punkten som ligger n�rmast COG
norms = sum(sqrt((gridCenters - repmat(COG, size(gridCenters, 1), 1)).^2),2);
minIndex = find(norms == min(norms),1);
newGridCenter = gridCenters(minIndex,:);

end

function np = removeOutsideBoundaries(np, range)

ndims = size(range.min, 2);
mins = repmat(range.min, size(np, 1), 1);
maxs = repmat(range.max, size(np, 1), 1);
np = np( ( sum(double(np <= maxs), 2) == ndims ) & ( sum(double(np >= mins), 2) == ndims ) , :);

end

function [ok message] = okInputs(gridParams)
ok = true;
message = [];
%check that all fields have same dimensions.
ok = ok & length(gridParams.start) == length(gridParams.range.min);
ok = ok & length(gridParams.start) == length(gridParams.range.max);
ok = ok & length(gridParams.start) == size(gridParams.stepsize, 2);
if (~ok)
    message = '.start, .min, .max and .stepsize fields must indicate the same nbr of dimensions';
    return
end

ok = ok & abs((gridParams.edgeLength / 2) - round(gridParams.edgeLength / 2)) > (eps * 100);
if (~ok)
    message = '.edgeLength field must be an odd integer';
    return
end


% check that zoom levels stay the same or decrease.
ok = ok & (sum(sum(gridParams.stepsize(2:end, :) - gridParams.stepsize(1:end-1,:) > 0)) == 0);
if (~ok)
    message = 'stepsizes must decrease of stay constant';
    return
end


end


function lasso=generatelasso(ndims, scale, npoints)
%GENERATELASSO create a "squared" hollow grid.
%
% LASSO=GENERATELASSO(NDIMS, SCALE, NPOINTS)
% For NDIMS=2 it create a hollow grid around origin with NPOINTS between
% the corners. For NDIMS=3 it create a hollow cube. SCALE is the distance
% from origin and NDIMS number of dimensions.



n = npoints+2;
a = linspace(-scale, scale, n)';
lasso = zeros(n^ndims, ndims);

for i=1:ndims
    x = n^(i-1);
    y = n^(ndims - i);
    lasso(:,i) = repmat(colstack(repmat(a, 1, x)'), y ,1);
end;

end

function y=colstack(x)
% COLSTACK Stack columns of an image
%
%  y=colstack
%
% SEE ALSO icolstack

% $Id: colstack.m 3318 2007-04-04 20:31:03Z finn $

y=reshape(x,[size(x,1)*size(x,2),size(x,3)]);
end

