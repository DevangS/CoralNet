function np = gridCrawler(vp, fval, gridParams)
% np = gridCrawler(vp, fval, gridParams)
%
% GRIDCRAWLER uses an iterative gridsearch method to find local min. Works for N dimensions and
% for M levels of zoom. Once the method has reached a local minima for a
% zoom level it proceeds with the next, or returns an empty output which
% indicates convergence. The points returned by the method needs to be
% evaluated by the objective function and returned with corresponding
% function values.
%
% INPUTS
% vp, visitedPoints, is a [W x N] matrix where W indicates number of visited points so far.
% First function call will have vp = [ ].
% fval is a 1 x N vector with function values corresponding to each visited
% point. First function call will have fval = [].
%
% gridParams is a parameter struct with the following fields.
% gridParams.range.min = 1 x N
% gridParams.range.max = 1 x N
% gridParams.stepsize = M x N
% gridParams.start = 1 x N
% gridParams.edgeLength = indicates the size of each grid. Must be an odd
% number. Usually 3 or 5 for fast convergence.
%
% OUTPUTS
% np, NewPoints are the points generated by gridCrawler where the objective
% function needs to be evaluated. If this output is empty the search has
% converged.
%
% Version 2.2
% NOTE: the 'log' option has been removed in this version for a simpler interface. If you wish to
% perform a logarithmic gridsearch, just take the exponential of the
% generated points. Removed the plausible infpointremoval and the
% maxNbrMinpoints. Just got messy.
%
% Oscar Beijbom [20 Feb 2010]
%
% TODO: reimplement maxNbrMinPoints.

np = [];

% check that params has the right format.
okInputs(gridParams);

% If all fval == inf or fval == Nan. Abort.
if ( ~isempty(vp) && ( (sum(fval == Inf) == length(fval)) || ( sum(isnan(fval)) == length(fval) ) ) )
    return
end

% initialize.
nbrZooms = size(gridParams.stepsize, 1);
zoomLevel = 1;
gridCenter = gridParams.start;

done = false;
while (~done)

    % create new points.
    np = createNewPoints(gridCenter, gridParams.edgeLength, gridParams.stepsize(zoomLevel, :), size(gridParams.start,2));

    % remove duplicates
    np = removeDoubles(np);
    
    % remove those outside the boundaries
    np = removeOutsideBoundaries(np, gridParams.range);
    
    % remove those that already exist in vp.
    npPruned = removeExisting(np, vp);
    
    if (isempty(npPruned)) %we have already done this grid!
        npFval = findNpFvals(np, vp, fval); %look at the fvals for the current nps.
        newGridCenter = findNewGridCenter(np(npFval == min(npFval),:)); %use only the values in this current grid.
        if (newGridCenter == gridCenter)
            % we have converged on this zoom level
            zoomLevel = zoomLevel + 1;
            if (zoomLevel > nbrZooms) %done!
                done = true;
            end
        end
        gridCenter = newGridCenter;
    else
        done = true;
    end
    np = npPruned;
    
end

end

function np = createNewPoints(newGridCenter, edgeLength, stepsize, ndims)

lasso = generatelasso(ndims, ceil((edgeLength - 2)/2), edgeLength - 2);
np = zeros(size(lasso,1)*size(newGridCenter, 1), ndims);
pos = 1;
for k = 1 : size(newGridCenter, 1)
    thisGridCenter = newGridCenter(k, :);
    for l = 1 : size(lasso, 1)
        np(pos, :) = thisGridCenter + lasso(l,:) .* stepsize;
        pos = pos + 1;
    end
end
end

function np = removeDoubles(np)
keepNP = true(size(np, 1), 1);
for i = 1 : size(np) - 1
    for j = i + 1 : size(np)
        if ( norm(np(i,:) - np(j,:)) < ( eps * 100 ) )
            keepNP(i) = false;
        end
    end
end
np = np(keepNP,:);
end

function np = removeExisting(np, vp)
% ta bort de som redan finns!
keepNP = true(size(np, 1), 1);
for i = 1 : size(np)
    for j = 1 : size(vp)
        if ( norm(np(i,:) - vp(j,:)) < ( eps * 100 ) )
            keepNP(i) = false;
        end
    end
end
np = np(keepNP,:);
end


function newGridCenter = findNewGridCenter(gridCenters)

COG = mean(gridCenters, 1); %center of gravity

%hitta den punkten som ligger nï¿½rmast COG
norms = sum(sqrt((gridCenters - repmat(COG, size(gridCenters, 1), 1)).^2),2);
[~, minIndex] = min(norms);
newGridCenter = gridCenters(minIndex(1),:);

end

function np = removeOutsideBoundaries(np, range)

ndims = size(range.min, 2);
mins = repmat(range.min, size(np, 1), 1);
maxs = repmat(range.max, size(np, 1), 1);
np = np( ( sum(double(np <= maxs), 2) == ndims ) & ( sum(double(np >= mins), 2) == ndims ) , :);

end

function npFval = findNpFvals(np, vp, fvals)
    
    nbrNps = size(np, 1);
    npFval = zeros(nbrNps, 1);
    for i = 1 : nbrNps
        for j = 1 : size(vp, 1)
            if ( norm(np(i,:) - vp(j,:)) < ( eps * 100 ) )
                npFval(i) = fvals(j);
            end
        end
    end
end


function [ok message] = okInputs(gridParams)
ok = true;
message = [];
%check that all fields have same dimensions.
ok = ok & length(gridParams.start) == length(gridParams.range.min);
ok = ok & length(gridParams.start) == length(gridParams.range.max);
ok = ok & length(gridParams.start) == size(gridParams.stepsize, 2);
if (~ok)
    error('.start, .min, .max and .stepsize fields must indicate the same nbr of dimensions');
end

ok = ok & abs((gridParams.edgeLength / 2) - round(gridParams.edgeLength / 2)) > (eps * 100);
if (~ok)
    error('.edgeLength field must be an odd integer');
end


% check that zoom levels stay the same or decrease.
ok = ok & (sum(sum(gridParams.stepsize(2:end, :) - gridParams.stepsize(1:end-1,:) > 0)) == 0);
if (~ok)
    error('stepsizes must decrease of stay constant');
end


end


function lasso=generatelasso(ndims, scale, npoints)
%GENERATELASSO create a "squared" hollow grid.
%
% LASSO=GENERATELASSO(NDIMS, SCALE, NPOINTS)
% For NDIMS=2 it create a hollow grid around origin with NPOINTS between
% the corners. For NDIMS=3 it create a hollow cube. SCALE is the distance
% from origin and NDIMS number of dimensions.



n = npoints+2;
a = linspace(-scale, scale, n)';
lasso = zeros(n^ndims, ndims);

for i=1:ndims
    x = n^(i-1);
    y = n^(ndims - i);
    lasso(:,i) = repmat(colstack(repmat(a, 1, x)'), y ,1);
end;

end

function y=colstack(x)
% COLSTACK Stack columns of an image
%
%  y=colstack
%
% SEE ALSO icolstack

% $Id: colstack.m 3318 2007-04-04 20:31:03Z finn $

y=reshape(x,[size(x,1)*size(x,2),size(x,3)]);
end

